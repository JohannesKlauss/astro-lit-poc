import {
  L,
  Z,
  x
} from "./chunk-4OMKGV45.js";

// node_modules/lit-html/directive.js
var t = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };

// node_modules/lit-html/directive-helpers.js
var { I: l } = L;
var t2 = (o) => null === o || "object" != typeof o && "function" != typeof o;
var n = (o, l2) => void 0 === l2 ? void 0 !== (null == o ? void 0 : o._$litType$) : (null == o ? void 0 : o._$litType$) === l2;
var e = (o) => void 0 === o.strings;

// node_modules/lit-html/experimental-hydrate.js
var { R: i, D: a, V: s, I: c, F: d } = L;
var f = (e2, t3, r = {}) => {
  if (void 0 !== t3._$litPart$)
    throw Error("container already contains a live render");
  let n2, o;
  const l2 = [], i2 = document.createTreeWalker(t3, NodeFilter.SHOW_COMMENT, null, false);
  let a2;
  for (; null !== (a2 = i2.nextNode()); ) {
    const t4 = a2.data;
    if (t4.startsWith("lit-part")) {
      if (0 === l2.length && void 0 !== n2)
        throw Error("there must be only one root part per container");
      o = p(e2, a2, l2, r), null != n2 || (n2 = o);
    } else if (t4.startsWith("lit-node"))
      h(a2, l2, r);
    else if (t4.startsWith("/lit-part")) {
      if (1 === l2.length && o !== n2)
        throw Error("internal error");
      o = u(a2, o, l2);
    }
  }
  console.assert(void 0 !== n2, "there should be exactly one root part in a render container"), t3._$litPart$ = n2;
};
var p = (t3, r, l2, d2) => {
  let f2, p2;
  if (0 === l2.length)
    p2 = new c(r, null, void 0, d2), f2 = t3;
  else {
    const e2 = l2[l2.length - 1];
    if ("template-instance" === e2.type)
      p2 = new c(r, null, e2.instance, d2), e2.instance.u.push(p2), f2 = e2.result.values[e2.instancePartIndex++], e2.templatePartIndex++;
    else if ("iterable" === e2.type) {
      p2 = new c(r, null, e2.part, d2);
      const t4 = e2.iterator.next();
      if (t4.done)
        throw f2 = void 0, e2.done = true, Error("Unhandled shorter than expected iterable");
      f2 = t4.value, e2.part._$AH.push(p2);
    } else
      p2 = new c(r, null, e2.part, d2);
  }
  if (f2 = s(p2, f2), f2 === x)
    l2.push({ part: p2, type: "leaf" });
  else if (t2(f2))
    l2.push({ part: p2, type: "leaf" }), p2._$AH = f2;
  else if (n(f2)) {
    const e2 = "lit-part " + m(f2);
    if (r.data !== e2)
      throw Error("Hydration value mismatch: Unexpected TemplateResult rendered to part");
    {
      const e3 = c.prototype._$AC(f2), t4 = new i(e3, p2);
      l2.push({ type: "template-instance", instance: t4, part: p2, templatePartIndex: 0, instancePartIndex: 0, result: f2 }), p2._$AH = t4;
    }
  } else
    a(f2) ? (l2.push({ part: p2, type: "iterable", value: f2, iterator: f2[Symbol.iterator](), done: false }), p2._$AH = []) : (l2.push({ part: p2, type: "leaf" }), p2._$AH = null == f2 ? "" : f2);
  return p2;
};
var u = (e2, t3, r) => {
  if (void 0 === t3)
    throw Error("unbalanced part marker");
  t3._$AB = e2;
  const n2 = r.pop();
  if ("iterable" === n2.type && !n2.iterator.next().done)
    throw Error("unexpected longer than expected iterable");
  if (r.length > 0)
    return r[r.length - 1].part;
};
var h = (e2, t3, n2) => {
  var o;
  const i2 = /lit-node (\d+)/.exec(e2.data), a2 = parseInt(i2[1]), c2 = null !== (o = e2.previousElementSibling) && void 0 !== o ? o : e2.parentElement;
  if (null === c2)
    throw Error("could not find node for attribute parts");
  c2.removeAttribute("defer-hydration");
  const f2 = t3[t3.length - 1];
  if ("template-instance" !== f2.type)
    throw Error("internal error");
  {
    const e3 = f2.instance;
    for (; ; ) {
      const t4 = e3._$AD.parts[f2.templatePartIndex];
      if (void 0 === t4 || t4.type !== t.ATTRIBUTE && t4.type !== t.ELEMENT || t4.index !== a2)
        break;
      if (t4.type === t.ATTRIBUTE) {
        const o2 = new t4.ctor(c2, t4.name, t4.strings, f2.instance, n2), i3 = e(o2) ? f2.result.values[f2.instancePartIndex] : f2.result.values, a3 = !(o2.type === t.EVENT || o2.type === t.PROPERTY);
        o2._$AI(i3, o2, f2.instancePartIndex, a3), f2.instancePartIndex += t4.strings.length - 1, e3.u.push(o2);
      } else {
        const t5 = new d(c2, f2.instance, n2);
        s(t5, f2.result.values[f2.instancePartIndex++]), e3.u.push(t5);
      }
      f2.templatePartIndex++;
    }
  }
};
var m = (e2) => {
  const t3 = new Uint32Array(2).fill(5381);
  for (const r2 of e2.strings)
    for (let e3 = 0; e3 < r2.length; e3++)
      t3[e3 % 2] = 33 * t3[e3 % 2] ^ r2.charCodeAt(e3);
  const r = String.fromCharCode(...new Uint8Array(t3.buffer));
  return btoa(r);
};

// node_modules/lit-element/experimental-hydrate-support.js
globalThis.litElementHydrateSupport = ({ LitElement: s2 }) => {
  const e2 = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(s2), "observedAttributes").get;
  Object.defineProperty(s2, "observedAttributes", { get() {
    return [...e2.call(this), "defer-hydration"];
  } });
  const h2 = s2.prototype.attributeChangedCallback;
  s2.prototype.attributeChangedCallback = function(t3, i2, s3) {
    "defer-hydration" === t3 && null === s3 && n2.call(this), h2.call(this, t3, i2, s3);
  };
  const n2 = s2.prototype.connectedCallback;
  s2.prototype.connectedCallback = function() {
    this.hasAttribute("defer-hydration") || n2.call(this);
  };
  const o = s2.prototype.createRenderRoot;
  s2.prototype.createRenderRoot = function() {
    return this.shadowRoot ? (this._$AG = true, this.shadowRoot) : o.call(this);
  };
  const r = Object.getPrototypeOf(s2.prototype).update;
  s2.prototype.update = function(s3) {
    const e3 = this.render();
    r.call(this, s3), this._$AG ? (this._$AG = false, f(e3, this.renderRoot, this.renderOptions)) : Z(e3, this.renderRoot, this.renderOptions);
  };
};
/*! Bundled license information:

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/experimental-hydrate.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/experimental-hydrate-support.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=chunk-RA3FYHHV.js.map
