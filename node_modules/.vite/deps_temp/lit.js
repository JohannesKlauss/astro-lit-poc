import {
  L,
  Z,
  b,
  w,
  x,
  y
} from "./chunk-4OMKGV45.js";

// node_modules/@lit/reactive-element/css-tag.js
var t = window;
var e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s = Symbol();
var n = /* @__PURE__ */ new WeakMap();
var o = class {
  constructor(t2, e3, n4) {
    if (this._$cssResult$ = true, n4 !== s)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t2, this.t = e3;
  }
  get styleSheet() {
    let t2 = this.o;
    const s4 = this.t;
    if (e && void 0 === t2) {
      const e3 = void 0 !== s4 && 1 === s4.length;
      e3 && (t2 = n.get(s4)), void 0 === t2 && ((this.o = t2 = new CSSStyleSheet()).replaceSync(this.cssText), e3 && n.set(s4, t2));
    }
    return t2;
  }
  toString() {
    return this.cssText;
  }
};
var r = (t2) => new o("string" == typeof t2 ? t2 : t2 + "", void 0, s);
var i = (t2, ...e3) => {
  const n4 = 1 === t2.length ? t2[0] : e3.reduce((e4, s4, n5) => e4 + ((t3) => {
    if (true === t3._$cssResult$)
      return t3.cssText;
    if ("number" == typeof t3)
      return t3;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t3 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s4) + t2[n5 + 1], t2[0]);
  return new o(n4, t2, s);
};
var S = (s4, n4) => {
  e ? s4.adoptedStyleSheets = n4.map((t2) => t2 instanceof CSSStyleSheet ? t2 : t2.styleSheet) : n4.forEach((e3) => {
    const n5 = document.createElement("style"), o5 = t.litNonce;
    void 0 !== o5 && n5.setAttribute("nonce", o5), n5.textContent = e3.cssText, s4.appendChild(n5);
  });
};
var c = e ? (t2) => t2 : (t2) => t2 instanceof CSSStyleSheet ? ((t3) => {
  let e3 = "";
  for (const s4 of t3.cssRules)
    e3 += s4.cssText;
  return r(e3);
})(t2) : t2;

// node_modules/@lit/reactive-element/reactive-element.js
var s2;
var e2 = window;
var r2 = e2.trustedTypes;
var h = r2 ? r2.emptyScript : "";
var o2 = e2.reactiveElementPolyfillSupport;
var n2 = { toAttribute(t2, i2) {
  switch (i2) {
    case Boolean:
      t2 = t2 ? h : null;
      break;
    case Object:
    case Array:
      t2 = null == t2 ? t2 : JSON.stringify(t2);
  }
  return t2;
}, fromAttribute(t2, i2) {
  let s4 = t2;
  switch (i2) {
    case Boolean:
      s4 = null !== t2;
      break;
    case Number:
      s4 = null === t2 ? null : Number(t2);
      break;
    case Object:
    case Array:
      try {
        s4 = JSON.parse(t2);
      } catch (t3) {
        s4 = null;
      }
  }
  return s4;
} };
var a = (t2, i2) => i2 !== t2 && (i2 == i2 || t2 == t2);
var l = { attribute: true, type: String, converter: n2, reflect: false, hasChanged: a };
var d = class extends HTMLElement {
  constructor() {
    super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$El = null, this.u();
  }
  static addInitializer(t2) {
    var i2;
    this.finalize(), (null !== (i2 = this.h) && void 0 !== i2 ? i2 : this.h = []).push(t2);
  }
  static get observedAttributes() {
    this.finalize();
    const t2 = [];
    return this.elementProperties.forEach((i2, s4) => {
      const e3 = this._$Ep(s4, i2);
      void 0 !== e3 && (this._$Ev.set(e3, s4), t2.push(e3));
    }), t2;
  }
  static createProperty(t2, i2 = l) {
    if (i2.state && (i2.attribute = false), this.finalize(), this.elementProperties.set(t2, i2), !i2.noAccessor && !this.prototype.hasOwnProperty(t2)) {
      const s4 = "symbol" == typeof t2 ? Symbol() : "__" + t2, e3 = this.getPropertyDescriptor(t2, s4, i2);
      void 0 !== e3 && Object.defineProperty(this.prototype, t2, e3);
    }
  }
  static getPropertyDescriptor(t2, i2, s4) {
    return { get() {
      return this[i2];
    }, set(e3) {
      const r4 = this[t2];
      this[i2] = e3, this.requestUpdate(t2, r4, s4);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t2) {
    return this.elementProperties.get(t2) || l;
  }
  static finalize() {
    if (this.hasOwnProperty("finalized"))
      return false;
    this.finalized = true;
    const t2 = Object.getPrototypeOf(this);
    if (t2.finalize(), void 0 !== t2.h && (this.h = [...t2.h]), this.elementProperties = new Map(t2.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
      const t3 = this.properties, i2 = [...Object.getOwnPropertyNames(t3), ...Object.getOwnPropertySymbols(t3)];
      for (const s4 of i2)
        this.createProperty(s4, t3[s4]);
    }
    return this.elementStyles = this.finalizeStyles(this.styles), true;
  }
  static finalizeStyles(i2) {
    const s4 = [];
    if (Array.isArray(i2)) {
      const e3 = new Set(i2.flat(1 / 0).reverse());
      for (const i3 of e3)
        s4.unshift(c(i3));
    } else
      void 0 !== i2 && s4.push(c(i2));
    return s4;
  }
  static _$Ep(t2, i2) {
    const s4 = i2.attribute;
    return false === s4 ? void 0 : "string" == typeof s4 ? s4 : "string" == typeof t2 ? t2.toLowerCase() : void 0;
  }
  u() {
    var t2;
    this._$E_ = new Promise((t3) => this.enableUpdating = t3), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), null === (t2 = this.constructor.h) || void 0 === t2 || t2.forEach((t3) => t3(this));
  }
  addController(t2) {
    var i2, s4;
    (null !== (i2 = this._$ES) && void 0 !== i2 ? i2 : this._$ES = []).push(t2), void 0 !== this.renderRoot && this.isConnected && (null === (s4 = t2.hostConnected) || void 0 === s4 || s4.call(t2));
  }
  removeController(t2) {
    var i2;
    null === (i2 = this._$ES) || void 0 === i2 || i2.splice(this._$ES.indexOf(t2) >>> 0, 1);
  }
  _$Eg() {
    this.constructor.elementProperties.forEach((t2, i2) => {
      this.hasOwnProperty(i2) && (this._$Ei.set(i2, this[i2]), delete this[i2]);
    });
  }
  createRenderRoot() {
    var t2;
    const s4 = null !== (t2 = this.shadowRoot) && void 0 !== t2 ? t2 : this.attachShadow(this.constructor.shadowRootOptions);
    return S(s4, this.constructor.elementStyles), s4;
  }
  connectedCallback() {
    var t2;
    void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), null === (t2 = this._$ES) || void 0 === t2 || t2.forEach((t3) => {
      var i2;
      return null === (i2 = t3.hostConnected) || void 0 === i2 ? void 0 : i2.call(t3);
    });
  }
  enableUpdating(t2) {
  }
  disconnectedCallback() {
    var t2;
    null === (t2 = this._$ES) || void 0 === t2 || t2.forEach((t3) => {
      var i2;
      return null === (i2 = t3.hostDisconnected) || void 0 === i2 ? void 0 : i2.call(t3);
    });
  }
  attributeChangedCallback(t2, i2, s4) {
    this._$AK(t2, s4);
  }
  _$EO(t2, i2, s4 = l) {
    var e3;
    const r4 = this.constructor._$Ep(t2, s4);
    if (void 0 !== r4 && true === s4.reflect) {
      const h3 = (void 0 !== (null === (e3 = s4.converter) || void 0 === e3 ? void 0 : e3.toAttribute) ? s4.converter : n2).toAttribute(i2, s4.type);
      this._$El = t2, null == h3 ? this.removeAttribute(r4) : this.setAttribute(r4, h3), this._$El = null;
    }
  }
  _$AK(t2, i2) {
    var s4;
    const e3 = this.constructor, r4 = e3._$Ev.get(t2);
    if (void 0 !== r4 && this._$El !== r4) {
      const t3 = e3.getPropertyOptions(r4), h3 = "function" == typeof t3.converter ? { fromAttribute: t3.converter } : void 0 !== (null === (s4 = t3.converter) || void 0 === s4 ? void 0 : s4.fromAttribute) ? t3.converter : n2;
      this._$El = r4, this[r4] = h3.fromAttribute(i2, t3.type), this._$El = null;
    }
  }
  requestUpdate(t2, i2, s4) {
    let e3 = true;
    void 0 !== t2 && (((s4 = s4 || this.constructor.getPropertyOptions(t2)).hasChanged || a)(this[t2], i2) ? (this._$AL.has(t2) || this._$AL.set(t2, i2), true === s4.reflect && this._$El !== t2 && (void 0 === this._$EC && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t2, s4))) : e3 = false), !this.isUpdatePending && e3 && (this._$E_ = this._$Ej());
  }
  async _$Ej() {
    this.isUpdatePending = true;
    try {
      await this._$E_;
    } catch (t3) {
      Promise.reject(t3);
    }
    const t2 = this.scheduleUpdate();
    return null != t2 && await t2, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t2;
    if (!this.isUpdatePending)
      return;
    this.hasUpdated, this._$Ei && (this._$Ei.forEach((t3, i3) => this[i3] = t3), this._$Ei = void 0);
    let i2 = false;
    const s4 = this._$AL;
    try {
      i2 = this.shouldUpdate(s4), i2 ? (this.willUpdate(s4), null === (t2 = this._$ES) || void 0 === t2 || t2.forEach((t3) => {
        var i3;
        return null === (i3 = t3.hostUpdate) || void 0 === i3 ? void 0 : i3.call(t3);
      }), this.update(s4)) : this._$Ek();
    } catch (t3) {
      throw i2 = false, this._$Ek(), t3;
    }
    i2 && this._$AE(s4);
  }
  willUpdate(t2) {
  }
  _$AE(t2) {
    var i2;
    null === (i2 = this._$ES) || void 0 === i2 || i2.forEach((t3) => {
      var i3;
      return null === (i3 = t3.hostUpdated) || void 0 === i3 ? void 0 : i3.call(t3);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t2)), this.updated(t2);
  }
  _$Ek() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$E_;
  }
  shouldUpdate(t2) {
    return true;
  }
  update(t2) {
    void 0 !== this._$EC && (this._$EC.forEach((t3, i2) => this._$EO(i2, this[i2], t3)), this._$EC = void 0), this._$Ek();
  }
  updated(t2) {
  }
  firstUpdated(t2) {
  }
};
d.finalized = true, d.elementProperties = /* @__PURE__ */ new Map(), d.elementStyles = [], d.shadowRootOptions = { mode: "open" }, null == o2 || o2({ ReactiveElement: d }), (null !== (s2 = e2.reactiveElementVersions) && void 0 !== s2 ? s2 : e2.reactiveElementVersions = []).push("1.6.1");

// node_modules/lit-element/lit-element.js
var l2;
var o3;
var r3 = d;
var s3 = class extends d {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t2, e3;
    const i2 = super.createRenderRoot();
    return null !== (t2 = (e3 = this.renderOptions).renderBefore) && void 0 !== t2 || (e3.renderBefore = i2.firstChild), i2;
  }
  update(t2) {
    const i2 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t2), this._$Do = Z(i2, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t2;
    super.connectedCallback(), null === (t2 = this._$Do) || void 0 === t2 || t2.setConnected(true);
  }
  disconnectedCallback() {
    var t2;
    super.disconnectedCallback(), null === (t2 = this._$Do) || void 0 === t2 || t2.setConnected(false);
  }
  render() {
    return x;
  }
};
s3.finalized = true, s3._$litElement$ = true, null === (l2 = globalThis.litElementHydrateSupport) || void 0 === l2 || l2.call(globalThis, { LitElement: s3 });
var n3 = globalThis.litElementPolyfillSupport;
null == n3 || n3({ LitElement: s3 });
var h2 = { _$AK: (t2, e3, i2) => {
  t2._$AK(e3, i2);
}, _$AL: (t2) => t2._$AL };
(null !== (o3 = globalThis.litElementVersions) && void 0 !== o3 ? o3 : globalThis.litElementVersions = []).push("3.2.2");

// node_modules/lit-html/is-server.js
var o4 = false;
export {
  o as CSSResult,
  s3 as LitElement,
  d as ReactiveElement,
  r3 as UpdatingElement,
  h2 as _$LE,
  L as _$LH,
  S as adoptStyles,
  i as css,
  n2 as defaultConverter,
  c as getCompatibleStyle,
  y as html,
  o4 as isServer,
  x as noChange,
  a as notEqual,
  b as nothing,
  Z as render,
  e as supportsAdoptingStyleSheets,
  w as svg,
  r as unsafeCSS
};
/*! Bundled license information:

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=lit.js.map
